#import "/typ/templates/blog.typ": *

#show: main.with(
  title: "FPS Learn Memo 1",
  desc: [形式幂级数学习笔记1],
  date: "2025-12-16",
  tags: (
    blog-tags.alg,
    blog-tags.train,
    blog-tags.tech,
    blog-tags.rec
  ),
  show-outline: true,
)

#set text(size: 8pt)

#let msk = "■";
#let HL(s) = text(size: 10pt)[*#s*]

= 多项式 | 形式幂级数 1

本文为个人学习形式幂级数科技的笔记，内容主要为翻译柜子博客

== 概要

上一章中确认了各类计数问题可以被转成多项式（形式幂级数）问题，但光是这样的话，仅仅是把 dp 翻译了一遍，把数据结构换成了多项式。

从多项式角度去思考的话，dp的转移会清楚很多。另一方面，有时直接按照推出来的原式子做复杂度很高，为了更快地计算，往往需要把式子变形成易于计算的形式

== 约定
=== 二项式定理
$ (x+y)^n = sum_(0<=i<=n) binom(n, i)x^i y^(n-i) $

$binom(n, i)$ 是二项系数，有时记作 $C_n^i$ 。

对于 $i<0$ 或 $i>n$ 有 $binom(n, i) = 0$ ，因此求和范围随意，写成 $sum_(i=0)^infinity$ 也可以。

=== 等比数列和

对 $r!=1$ ，有 $sum_(i=0)^(n-1)r^i = (1-r^n)/(1-r)$ 成立。

=== 形式幂级数的 和 差 积

将形如 $F = sum_(i=0)^infinity f_n x^n$ 的式子称作形式幂级数，多项式是一种形式幂级数。

将 $G = sum_(i=0)^infinity g_n x^n$ 也看作形式幂级数时，它们的 和 差 积按以下规则定义：

$[x^n](F plus.minus G) = f_n plus.minus g_n$ ， $[x^n](F G) = sum_(i+k=n)f_i g_k$ 

由于单个系数的定义里不会出现无穷和，因此不需要极限操作也能形式化定义

$F+G$ ，$F G$ 的 $n$ 次以下部分，只由 $F$ ，$G$ 的 $n$ 次以下部分决定，若只关注 $n$ 次以下，则形式幂级数的运算规则与多项式对 $x^n$ 取模的运算完全相同

由此，形式幂级数的这三种运算也满足交换律、结合率、分配率

=== 形式幂级数环的位相

位相是为了定义极限引入的结构，对于形式幂级数 $F$ ，我们将其理解为：*次数越高的项越接近 0* 。利用这一点，就能定义形式幂级数的极限与收敛

#HL[定义]

形式幂级数数列 $F_1,F_2,F_3,...$ 收敛到 $F$ ，是指：对任意的 $k$ ，都存在某个 $N$ ，使得当 $n>=N$ 时， $F_n$ 与 $F$ 的 $x^k$ 次以下部分一致。

=== 形式幂级数的逆元

对任意形式幂级数 $F, G$ ，若 $F G = 1$ 成立，则称 $F$ 是 $G$ （或者称 $G$ 是 $F$）的逆元，记作 $F = 1 / G$ 。也可以写作 $F * 1/G$ 或 $F / G$

就像分数一样书写，实际上它和分数满足同样的计算规则，分数的计算规则来自结合率、分配率等，因此在这里同样成。

作为逆元，典型的例子是： $1/(1 - x) = 1 + x + x^2 + ... = sum_(n=0)^infinity x^n$

试着计算 $(1-x)(1 + x + x^2 + ...)$ ，就能确认除了常数项外系数都会变成 0 。

同理，当 $F$ 是没有常数项的形式幂级数时，$1/(1-F) = 1 + F + F^2 + ... = sum_(n=0)^infinity F^n$ 也成立。 

如果处理得当，右边在前面”位相”里说到的极限意义下成立。部分和从等比数列的和可得 $(1-F^N)/(1-F)$ 的形式，左右两边的差是 $F^N/(1-F)$ 。但如果 $F$ 含有常数项，则 $F^N$ 的低次项不会消失，极限意义下就不成立，从而无法保证正确性。

#pagebreak()

== 通过对 无穷和 变形来简化式子

=== 问题

将 $N$ 表示为正整数和的方案数？（不同顺序算不同方案）

若 $N = 4$ 则有 $4, 1 + 3, 3 + 1, 1 + 2 + 1, 2 + 1 + 1, 1 + 1 + 2, 2 + 2, 1 + 1 + 1 + 1$ 这 8 种。

对这个问题，如果把“和由多少个项组成”分类计算，就能用多项式计算：

令 $F = x + x^2 + x^3 + ...$ ，答案为 $[x^N]sum_(n=0)^infinity F^n$ 

这样和最简单的组合意义解法相比，已经绕远了，因为这变成了无穷和。

但推式子也能自然地解出来。

$F = x dot 1/(1-x) = x / (1-x)$

要求的是 $G = sum_(n=0)^infinity F^n$ ，可以写作：$G = 1/(1-F)$ 

将 $F = x/(1-x)$ 代入并整理，能得到： $G = (1-x)/(1-2x)$ 

进一步，$G = (1-x) dot 1/(1-2x) = (1-x)(1 + 2x + 4x^2 + 8x^3 + ...)$ 

据此可以算出 $N$ 次的系数：当 $N=0$ 时为 1 ，当 $N>=1$ 时为 $2^N-2^(N-1) = 2^(N-1)$ 

或者通过以下变形也能得到同样的结论：$G=1/2+1/2*1/(1-2x) = 1/2 + 1/2(1+2x+4x^2+8^3+...)$

#HL[总结]

只要能把文字题面翻译称式子，再去尽量找式子“最自然的表示”，就能得到计数的简单表示或计算方法，也就是推式子

另外，最优美的方法是利用组合意义

例如将 $4 = 1 + 2 + 1$ 看作 O | OO | O 插板，四分割就是在三个位置上选择是否插板，因此有 $2^3$ 种

#pagebreak()

== 利用因式分解

当式子可以因式分解时，有时能顺着分解将计算过程简化。例如：

=== 问题 #link("https://atcoder.jp/contests/arc012/tasks/arc012_4", msk)

在整点二维平面上，从原点出发随机游走。求 $T$ 步之后到达 $(a, b)$ 的路径数。

预先计算好二项式系数后，$O(1)$ 进行每次查询

令 $F = (x + x^(-1) + y + y^(-1))$ ，求 $[x^a y^b]F^T$ 

$F$ 可以按如下方式因式分解：$ F = (x y)^(-1)(x^2 y + x y^2 + x + y) = (x y)^(-1)(x y + 1)(x + y) $ 

将 $F^T$ 用二项式定理展开：

$ (x y)^(-T)(x y + 1)^T (x + y)^T = (x y)^(-1)sum_(i k)binom(T, i)binom(T, k)(x y)^i x^i y^(T-k) = sum_(i, k)binom(T, i)binom(T, k)x^(i+k-T)y^(i-k) $

因此，在计算 $[x^a y^b]f^T$ 时，只要令 $ I = {(i, k) | i + k - T = a, i - k = b} $ 

并计算 $ sum_((i, k) in I)binom(T, i)binom(T, k) $

即可。集合 $I$ 中最多只有一个元素，因此得到了 $O(1)$ 的计算。

#HL[总结]

这个问题在一维时很简单，二维时也可以将 $x, y$ 拆开，从而路径数可以写成二项式系数的乘积，也就是说这个问题可以用经典方法解决。

本体也可以使用 旋转 $45degree$ 的做法，将 $(x, y)$ 换成 $(x + y, x - y)$ 来考虑

这种方法与上面的因式分解法是对应的。

令 $A = x^(1/2)y^(1/2), B = x^(1/2)y^(-1/2)$ 则 $f = (A + A^(-1))(B + B^(-1))$ 

可以看作：一次移动独立地从 $A$ 或 $A^(-1)$ 中选一个、从 $B$ 或 $B^(-1)$ 中选一个。也就对应着”把平面旋转 $45degree$ 后在两个轴上独立地走“。

作为计数题很 adhoc 的技巧（ $45degree$ 旋转），从推式子操作出发，会被自然地导出。

类似题：#link("https://atcoder.jp/contests/kupc2019/tasks/kupc2019_k", msk)

#pagebreak()

== 通过前缀和导出 dp 转移

=== 问题

给定 $a_1, ..., a_N$ 。求选择整数 $0<=x_i<=a_i$ ，使得 $x_1 + ... + x_N = K$ 的方案数。（$N <= 100, a_i <= K <= 1^5$）

令 $F_i = 1 + x + x^2 + ... + x^(a_i)$ ，答案为 $[x^K]F_1 F_2 ... F_N$

一般来说，$d$ 次多项式的乘法需要 $O(d^2)$ 次的计算量，而把 $K$ 次规模的乘法做 $N$ 次，在本题的限制下很困难。

让我们从 $F_i$ 上找出某种结构，将计算量降下来。像因式分解时那样，继续寻找对多项式而言优美的表示方式。

由等比数列的和可知：$F_i = (1-x^(a_i + 1))/(1-x)$ 。虽然是除法，但它几乎等于两个稀疏多项式（系数很多 0 ）的乘积。

进一步： $F_i = 1/(1-x) dot (1-x^(a_i + 1))$ 这样写就能将它看作把 $F_i$ 因式分解了，

只是在多项式的范围里看，$1/(1-x)$ 不是多项式，所以这个式子不能用，从某种意义上来说，这里就体现出把考察对象扩张到形式幂级数的好处。

结论是：把某个多项式 $P$ 乘上 $F_i$ 的操作，可以拆成如下两步：
- 乘 $1/(1-x)$
- 乘 $1 - x^(a_i + 1)$

操作 1 如何快速计算？

一般地，设 $P = sum_(n=0)^infinity p_n x^n, P/(1-x) = Q = sum_(n=0)^infinity q_n x^n$

因为 $(1-x)Q = P$ ，有 $q_n = q_(n-1) + p_n$ 依次计算可以在 $O(d)$ 时间算出

一般来说，稀疏多项式的除法也可以用类似方法高速计算，这里的解释方式也可以基于 $1/(1-x) = 1 + x + x^2 + ...$ 来讲，可能更好理解，不过为了强调”发现将稀疏项分解开之后，自然会让计算量下降的思想，使用了上面的说明“、

操作 2 只需要按照乘法的定义计算，同样可以在相同量级内算完，它只是将系数序列整体右移 $(a_i + 1)$ 位后相减而已（一般地，稀疏多项式的乘法也能高速计算）

将两步合起来，最终由 $F_i$ 导出的 DP 转移可以按以下形式计算：

- 将数列替换为前缀和
- 取与向右平移 $a_i + 1$ 位的差，得到新的数列

由此我们知道它能被高效计算。

另外，形式幂级数的乘法满足交换律，因此将两步按相反顺序做也会得到同样的结果。为了计算 $product_i (1-a^(a_i))$ ，也可以先把所有的 $(1 - x^(a_i))$ 乘起来，再做 $N$ 次前缀和。 

如果学了更高级的算法，用 exp、log 等甚至能在 $N = 10^5$ 的限制下解决。

#pagebreak()

== 还原 DP 的导出

=== 问题