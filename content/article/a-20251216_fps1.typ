#import "/typ/templates/blog.typ": *

#show: main.with(
  title: "FPS Learn Memo 1",
  desc: [形式幂级数学习笔记1],
  date: "2025-12-16",
  tags: (
    blog-tags.alg,
    blog-tags.train,
    blog-tags.tech,
    blog-tags.rec
  ),
  show-outline: true,
)

#set text(size: 8pt)

#let msk = "■";
#let HL(s) = text(size: 10pt)[*#s*]

= 多项式 | 形式幂级数 1

本文为个人学习形式幂级数科技的笔记，内容主要为翻译柜子博客

== 概要

上一章中确认了各类计数问题可以被转成多项式（形式幂级数）问题，但光是这样的话，仅仅是把 dp 翻译了一遍，把数据结构换成了多项式。

从多项式角度去思考的话，dp的转移会清楚很多。另一方面，有时直接按照推出来的原式子做复杂度很高，为了更快地计算，往往需要把式子变形成易于计算的形式

== 约定
=== 二项式定理
$ (x+y)^n = sum_(0<=i<=n) binom(n, i)x^i y^(n-i) $

$binom(n, i)$ 是二项系数，有时记作 $C_n^i$ 。

对于 $i<0$ 或 $i>n$ 有 $binom(n, i) = 0$ ，因此求和范围随意，写成 $sum_(i=0)^infinity$ 也可以。

=== 等比数列和

对 $r!=1$ ，有 $sum_(i=0)^(n-1)r^i = (1-r^n)/(1-r)$ 成立。

=== 形式幂级数的 和 差 积

将形如 $F = sum_(i=0)^infinity f_n x^n$ 的式子称作形式幂级数，多项式是一种形式幂级数。

将 $G = sum_(i=0)^infinity g_n x^n$ 也看作形式幂级数时，它们的 和 差 积按以下规则定义：

$[x^n](F plus.minus G) = f_n plus.minus g_n$ ， $[x^n](F G) = sum_(i+k=n)f_i g_k$ 

由于单个系数的定义里不会出现无穷和，因此不需要极限操作也能形式化定义

$F+G$ ，$F G$ 的 $n$ 次以下部分，只由 $F$ ，$G$ 的 $n$ 次以下部分决定，若只关注 $n$ 次以下，则形式幂级数的运算规则与多项式对 $x^n$ 取模的运算完全相同

由此，形式幂级数的这三种运算也满足交换律、结合率、分配率

=== 形式幂级数环的位相

位相是为了定义极限引入的结构，对于形式幂级数 $F$ ，我们将其理解为：*次数越高的项越接近 0* 。利用这一点，就能定义形式幂级数的极限与收敛

#HL[定义]

形式幂级数数列 $F_1,F_2,F_3,...$ 收敛到 $F$ ，是指：对任意的 $k$ ，都存在某个 $N$ ，使得当 $n>=N$ 时， $F_n$ 与 $F$ 的 $x^k$ 次以下部分一致。

=== 形式幂级数的逆元

对任意形式幂级数 $F, G$ ，若 $F G = 1$ 成立，则称 $F$ 是 $G$ （或者称 $G$ 是 $F$）的逆元，记作 $F = 1 / G$ 。也可以写作 $F * 1/G$ 或 $F / G$

就像分数一样书写，实际上它和分数满足同样的计算规则，分数的计算规则来自结合率、分配率等，因此在这里同样成。

作为逆元，典型的例子是： $1/(1 - x) = 1 + x + x^2 + ... = sum_(n=0)^infinity x^n$

试着计算 $(1-x)(1 + x + x^2 + ...)$ ，就能确认除了常数项外系数都会变成 0 。

同理，当 $F$ 是没有常数项的形式幂级数时，$1/(1-F) = 1 + F + F^2 + ... = sum_(n=0)^infinity F^n$ 也成立。 

如果处理得当，右边在前面”位相”里说到的极限意义下成立。部分和从等比数列的和可得 $(1-F^N)/(1-F)$ 的形式，左右两边的差是 $F^N/(1-F)$ 。但如果 $F$ 含有常数项，则 $F^N$ 的低次项不会消失，极限意义下就不成立，从而无法保证正确性。

#pagebreak()

== 通过对 无穷和 变形来简化式子

=== 问题

将 $N$ 表示为正整数和的方案数？（不同顺序算不同方案）

若 $N = 4$ 则有 $4, 1 + 3, 3 + 1, 1 + 2 + 1, 2 + 1 + 1, 1 + 1 + 2, 2 + 2, 1 + 1 + 1 + 1$ 这 8 种。

对这个问题，如果把“和由多少个项组成”分类计算，就能用多项式计算：

令 $F = x + x^2 + x^3 + ...$ ，答案为 $[x^N]sum_(n=0)^infinity F^n$ 

这样和最简单的组合意义解法相比，已经绕远了，因为这变成了无穷和。

但推式子也能自然地解出来。

$F = x dot 1/(1-x) = x / (1-x)$

要求的是 $G = sum_(n=0)^infinity F^n$ ，可以写作：$G = 1/(1-F)$ 

将 $F = x/(1-x)$ 代入并整理，能得到： $G = (1-x)/(1-2x)$ 

进一步，$G = (1-x) dot 1/(1-2x) = (1-x)(1 + 2x + 4x^2 + 8x^3 + ...)$ 

据此可以算出 $N$ 次的系数：当 $N=0$ 时为 1 ，当 $N>=1$ 时为 $2^N-2^(N-1) = 2^(N-1)$ 

或者通过以下变形也能得到同样的结论：$G=1/2+1/2*1/(1-2x) = 1/2 + 1/2(1+2x+4x^2+8^3+...)$

#HL[总结]

只要能把文字题面翻译称式子，再去尽量找式子“最自然的表示”，就能得到计数的简单表示或计算方法，也就是推式子

另外，最优美的方法是利用组合意义

例如将 $4 = 1 + 2 + 1$ 看作 O | OO | O 插板，四分割就是在三个位置上选择是否插板，因此有 $2^3$ 种

#pagebreak()

== 利用因式分解

当式子可以因式分解时，有时能顺着分解将计算过程简化。例如：

=== 问题 #link("https://atcoder.jp/contests/arc012/tasks/arc012_4", msk)

在整点二维平面上，从原点出发随机游走。求 $T$ 步之后到达 $(a, b)$ 的路径数。

预先计算好二项式系数后，$O(1)$ 进行每次查询

令 $F = (x + x^(-1) + y + y^(-1))$ ，求 $[x^a y^b]F^T$ 

$F$ 可以按如下方式因式分解：$ F = (x y)^(-1)(x^2 y + x y^2 + x + y) = (x y)^(-1)(x y + 1)(x + y) $ 

将 $F^T$ 用二项式定理展开：

$ (x y)^(-T)(x y + 1)^T (x + y)^T = (x y)^(-1)sum_(i k)binom(T, i)binom(T, k)(x y)^i x^i y^(T-k) = sum_(i, k)binom(T, i)binom(T, k)x^(i+k-T)y^(i-k) $

因此，在计算 $[x^a y^b]f^T$ 时，只要令 $ I = {(i, k) | i + k - T = a, i - k = b} $ 

并计算 $ sum_((i, k) in I)binom(T, i)binom(T, k) $

即可。集合 $I$ 中最多只有一个元素，因此得到了 $O(1)$ 的计算。

#HL[总结]

这个问题在一维时很简单，二维时也可以将 $x, y$ 拆开，从而路径数可以写成二项式系数的乘积，也就是说这个问题可以用经典方法解决。

本体也可以使用 旋转 $45degree$ 的做法，将 $(x, y)$ 换成 $(x + y, x - y)$ 来考虑

这种方法与上面的因式分解法是对应的。

令 $A = x^(1/2)y^(1/2), B = x^(1/2)y^(-1/2)$ 则 $f = (A + A^(-1))(B + B^(-1))$ 

可以看作：一次移动独立地从 $A$ 或 $A^(-1)$ 中选一个、从 $B$ 或 $B^(-1)$ 中选一个。也就对应着”把平面旋转 $45degree$ 后在两个轴上独立地走“。

作为计数题很 adhoc 的技巧（ $45degree$ 旋转），从推式子操作出发，会被自然地导出。

类似题：#link("https://atcoder.jp/contests/kupc2019/tasks/kupc2019_k", msk)

#pagebreak()

== 通过前缀和导出 dp 转移

=== 问题 #link("https://atcoder.jp/contests/dp/tasks/dp_m", msk)

给定 $a_1, ..., a_N$ 。求选择整数 $0<=x_i<=a_i$ ，使得 $x_1 + ... + x_N = K$ 的方案数。（$N <= 100, a_i <= K <= 1^5$）

#HL[解答]

令 $F_i = 1 + x + x^2 + ... + x^(a_i)$ ，答案为 $[x^K]F_1 F_2 ... F_N$

一般来说，$d$ 次多项式的乘法需要 $O(d^2)$ 次的计算量，而把 $K$ 次规模的乘法做 $N$ 次，在本题的限制下很困难。

让我们从 $F_i$ 上找出某种结构，将计算量降下来。像因式分解时那样，继续寻找对多项式而言优美的表示方式。

由等比数列的和可知：$F_i = (1-x^(a_i + 1))/(1-x)$ 。虽然是除法，但它几乎等于两个稀疏多项式（系数很多 0 ）的乘积。

进一步： $F_i = 1/(1-x) dot (1-x^(a_i + 1))$ 这样写就能将它看作把 $F_i$ 因式分解了，

只是在多项式的范围里看，$1/(1-x)$ 不是多项式，所以这个式子不能用，从某种意义上来说，这里就体现出把考察对象扩张到形式幂级数的好处。

结论是：把某个多项式 $P$ 乘上 $F_i$ 的操作，可以拆成如下两步：
- 乘 $1/(1-x)$
- 乘 $1 - x^(a_i + 1)$

操作 1 如何快速计算？

一般地，设 $P = sum_(n=0)^infinity p_n x^n, P/(1-x) = Q = sum_(n=0)^infinity q_n x^n$

因为 $(1-x)Q = P$ ，有 $q_n = q_(n-1) + p_n$ 依次计算可以在 $O(d)$ 时间算出

一般来说，稀疏多项式的除法也可以用类似方法高速计算，这里的解释方式也可以基于 $1/(1-x) = 1 + x + x^2 + ...$ 来讲，可能更好理解，不过为了强调”发现将稀疏项分解开之后，自然会让计算量下降的思想，使用了上面的说明“、

操作 2 只需要按照乘法的定义计算，同样可以在相同量级内算完，它只是将系数序列整体右移 $(a_i + 1)$ 位后相减而已（一般地，稀疏多项式的乘法也能高速计算）

将两步合起来，最终由 $F_i$ 导出的 DP 转移可以按以下形式计算：

- 将数列替换为前缀和
- 取与向右平移 $a_i + 1$ 位的差，得到新的数列

由此我们知道它能被高效计算。

另外，形式幂级数的乘法满足交换律，因此将两步按相反顺序做也会得到同样的结果。为了计算 $product_i (1-a^(a_i))$ ，也可以先把所有的 $(1 - x^(a_i))$ 乘起来，再做 $N$ 次前缀和。 

如果学了更高级的算法，用 exp、log 等甚至能在 $N = 10^5$ 的限制下解决。

#pagebreak()

== 还原 DP 的导出

=== 问题 #link("https://atcoder.jp/contests/arc028/tasks/arc028_4", msk)

给定 $a_1, ..., a_N$ 。求选择整数 $0<=x_i<=a_i$ ，使得 $x_1 + ... + x_N = K$ 的方案数。

回答 $Q$ 个查询：在 $x_k_i = c_k_i$ 条件下计数 （$N <= 2000, 0 <= a_i <= M <= 2000, Q <= 5*10^5$）

#HL[解答]

这是上一题的变形版本。$Q$ 个查询太多了，最终等价于要对所有的 $(k, c_k)$ 都进行计算，考虑如下问题：

令 $F_i = 1 + x + x^2 + ... + x^(a_i)$ 对每个 $i$ 计算 $product_(k != i) F_k$ 的 $M$ 次以下部分。

当要从整体乘积中去掉一个时，经典技巧是分别算左右的前缀乘积（列：#link("https://atcoder.jp/contests/abc125/tasks/abc125_c", msk)）。但把左右的乘积再合并要花 $O(M^2)$ ，做 $N$ 次很难（可以 fft ）。我们想再多找一些结构。

还有一种自然的做法：
- 先计算 $F = product_k F_k$
- 用 $product_(k != i) F_k = F / F_i$ 来得到目标

那么如何用 $F$ 除以 $F_i$ 呢？

有 $F_i = (1-x^(a_i + 1)) / (1-x)$ ，所以 $F/F_i = F dot (1 - x) * 1 / (1-x^(a_i + 1))$

也就是说，从 $F$ 得到的 $F / F_i$ 的操作是：
- 乘 $(1-x)$
- 除 $(1-x^(a_i + 1))$ 

这两者都是稀疏多项式的乘除，因此可以在 $O(M)$ 内实现目标。更具体地，对系数的操作是：
- 取差分数列
- 令 $d = a_i + 1$ ，做步长为 $d$ 的前缀和（从小 $n$ 往大 $n$ 推， $a_n <- a_n + a_(n-d)$ ）

#HL[总结]

使用前缀和更新 dp 还原 dp 这类看起来是个别技巧的东西，从式子的角度看只是简单的乘法 | 除法。

#pagebreak()

== 应用交换律和快速幂

=== 问题 #link("https://atcoder.jp/contests/abc135/tasks/abc135_d", msk)

给定形如”？？？？？5“的字符串，将其中的”？“用 $0~9$ 的数字填充，使其成为 13 的倍数的方案数。（$N <= 10^5$）

#HL[解答]

首先归结到多项式运算。
- 个位：加 5
- 十位：从 $+0, +10, +20, ..., +90$ 中选
- 百位：从 $+0, +100, +200, ..., +900$ 中选
- ...
已经固定的数字部分逐位累计，除此之外，在 $10^k$ 位上的”？“对应乘上多项式 $F_k = sum_(n=0)^9 x^(10^k n)$

我们只关心指数 $mod 13$ 的值，因此在多项式了里加入 $x^13 = 1$ 后计算乘积即可（这个实际上是在余数环 $K[X] \/ (X^13 - 1)$ 上的运算）

对 $x^5$ 之类的乘法只需要将系数位置平移。进一步，利用 $F_n = F_(n + 6)$ ，可以发现“次数”本质上是周期性的：

计算 $F_0^(a_0) F_1^(a_1)...F_5^(a_5)$ $(x^13 = 1)$ $sum a_i = N <= 10^5$ 

使用朴素乘法，需要将多项式乘 $N$ 次。但如果对大的 $a$ 高效计算 $F^a$ ，可以使用快速幂。

所以这题的主要部分能在关于 $N$ 的 $O(log N)$ 时间内完成（统计“？”的位置仍然需要 $O(N)$ ，因此整体是 $O(N)$ 的）

#HL[总结]

意识到“本题计算量可以降下来”的人并不多。在应用快速幂时，多项式乘法的交换律和结合率在本质上都被使用了。但对多项式而言，这些性质即使作为”新算法知识“去学常常被很自然地使用。

用 dp 的语言来说：
- 将数列卷入本身满足交换律、结合率
- 转移是线性的，因此可以写成矩阵，于是满足结合率

很多人会觉得多项式比矩阵更容易在高次数范围内处理。另外，从计算量上看，若能用多项式做的场景，就这样做会更有利（ $D$ 次多项式乘法的朴素计算是 $O(D^2)$ ，而 $D times D$ 方阵矩乘的朴素计算是 $O(D^3)$ ）。

== 结语

本次的内容总结就是：
- 很多问题都能自然地用形式幂级数的形式表示出来
- 一旦 dp 变得”大到算不动“，只要找到某种结构（比如组合意义），就能把 dp 快速计算出来

例子中很多都是不用多项式也能解决的问题，并且在各个问题中往往用组合意义来解释更简单或者自然，但请注意：一些看起来完全不同的计数技巧，能简化式子的原因是同一个方法导出的。